<!doctype html>
<!--
  Quantum Scarring: interactive single-file page
  - Save as index.html and push to a GitHub repo (see footer instructions).
  - Billiard simulation (Bunimovich stadium) is implemented in JS and runs on static hosting.
  - Images suggested are from Wikimedia Commons (attributions in References).
  References & hosting docs:
    GitHub Pages quickstart / creating pages. :contentReference[oaicite:1]{index=1}
    Bunimovich stadium / double-pendulum images: Wikimedia Commons. :contentReference[oaicite:2]{index=2}
-->

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Quantum Scarring: Where Classical Chaos Meets Quantum Order</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<style>
  /* ---------------------------
     Palette + global tidy-up
     --------------------------- */
  :root{
    --bg-900: #050612;
    --bg-800: #0f1724;
    --primary: #00d1ff;
    --magenta: #ff6bd6;
    --lime: #7cffb2;
    --muted: #b9c6d3;
    --glass: rgba(255,255,255,0.06);
    --gradient: linear-gradient(135deg, var(--primary), var(--magenta));
    --card: rgba(255,255,255,0.03);
  }

  *{ box-sizing: border-box; margin:0; padding:0; font-family: "Segoe UI", system-ui, -apple-system, "Helvetica Neue", Arial; }
  html { scroll-behavior: smooth; scroll-snap-type: y proximity; height:100%; }
  body { background: var(--bg-900); color: var(--muted); min-height:100vh; overflow-x:hidden; }

  section { min-height:100vh; padding:4rem 1.5rem; display:flex; flex-direction:column; align-items:center; justify-content:center; position:relative; scroll-snap-align:start; scroll-snap-stop:always; }
  .section-bg { position:absolute; inset:0; background-size:cover; background-position:center; opacity:0.12; z-index:0; filter: blur(2px); }
  .section-title { font-size:2.8rem; background:var(--gradient); -webkit-background-clip:text; background-clip:text; color:transparent; z-index:2; margin-bottom:1rem; }
  .content { max-width:1100px; font-size:1.05rem; line-height:1.6; text-align:center; z-index:2; margin-bottom:1.4rem; }

  /* Hero */
  #hero { background: linear-gradient(135deg, var(--bg-900), #111126 80%); text-align:center; }
  .hero-title { font-size:4rem; background:var(--gradient); -webkit-background-clip:text; background-clip:text; color:transparent; margin-bottom:0.4rem; }
  .hero-subtitle { color:var(--muted); margin-bottom:1rem; }

  /* visualization container */
  .visualization-container { width:100%; max-width:980px; height:420px; border-radius:14px; overflow:hidden; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06)); border:1px solid rgba(255,255,255,0.04); position:relative; z-index:2; box-shadow: 0 10px 30px rgba(0,0,0,0.6); }

  /* nav-dots */
  .nav-dots { position:fixed; right:1.5rem; top:50%; transform:translateY(-50%); z-index:60; display:flex; flex-direction:column; gap:0.6rem; }
  .dot { width:14px; height:14px; border-radius:50%; background:rgba(255,255,255,0.18); cursor:pointer; position:relative; display:flex; align-items:center; justify-content:center; }
  .dot.active { background:linear-gradient(90deg,var(--primary),var(--magenta)); box-shadow:0 6px 14px rgba(0,0,0,0.5); transform:scale(1.12); }
  .dot-label { position:absolute; right:22px; top:50%; transform:translateY(-50%); background:rgba(5,6,18,0.8); padding:0.25rem 0.6rem; border-radius:12px; font-size:0.82rem; color:var(--muted); white-space:nowrap; opacity:0; transition:opacity .18s; pointer-events:none; }
  .dot:hover .dot-label { opacity:1; }

  /* benefit cards + CTA */
  .research-benefits { display:flex; gap:1rem; margin-top:1.4rem; flex-wrap:wrap; justify-content:center; }
  .benefit-card { width:260px; background:var(--card); padding:1.4rem; border-radius:12px; border:1px solid rgba(255,255,255,0.03); }
  .benefit-icon { font-size:2.4rem; background:var(--gradient); -webkit-background-clip:text; background-clip:text; color:transparent; margin-bottom:0.6rem; }

  /* controls */
  .controls { position:absolute; right:1rem; bottom:1rem; z-index:30; display:flex; gap:0.6rem; background: rgba(0,0,0,0.32); padding:0.6rem; border-radius:10px; border:1px solid rgba(255,255,255,0.04); font-size:0.9rem; }
  .controls label { color:var(--muted); display:flex; align-items:center; gap:0.4rem; }

  /* canvas styles */
  canvas { display:block; width:100%; height:100%; background:linear-gradient(180deg, rgba(2,6,23,0.07), rgba(0,0,0,0.25)); }

  footer { padding:1.2rem; text-align:center; border-top:1px solid rgba(255,255,255,0.04); margin-top:1rem; color:var(--muted); font-size:0.9rem; }
  .refs { text-align:left; max-width:980px; margin:1rem auto; color:var(--muted); font-size:0.9rem; line-height:1.4; }

  @media (max-width:768px){
    .hero-title { font-size:2.4rem; }
    .section-title { font-size:1.8rem; }
    .nav-dots { right:0.6rem; }
    .visualization-container { height:320px; }
    .controls { bottom:auto; top:0.8rem; right:0.8rem; flex-direction:column; }
  }
</style>
</head>
<body>
  <!-- NAV DOTS -->
  <div class="nav-dots" aria-hidden="false">
    <div class="dot active" data-section="hero"><span class="dot-label">Intro</span></div>
    <div class="dot" data-section="chaos"><span class="dot-label">Classical Chaos</span></div>
    <div class="dot" data-section="trapped-ions"><span class="dot-label">Trapped Ions</span></div>
    <div class="dot" data-section="scarring"><span class="dot-label">Scarring</span></div>
    <div class="dot" data-section="applications"><span class="dot-label">Applications</span></div>
    <div class="dot" data-section="cta"><span class="dot-label">Get Involved</span></div>
  </div>

  <!-- HERO -->
  <section id="hero">
    <div class="section-bg" style="background-image:url('https://upload.wikimedia.org/wikipedia/commons/2/29/DoublePendulumLongShutter.jpg');"></div>
    <h1 class="hero-title">Quantum Scarring</h1>
    <p class="hero-subtitle">Where Classical Chaos Meets Quantum Order</p>
    <p class="content">Discover how chaotic classical systems — like billiards or a double pendulum — leave surprising imprints in quantum wavefunctions. This page highlights intuition, interactivity, and references to get you started on research and demos.</p>
    <a class="cta-button" href="#chaos" style="margin-top:0.8rem;padding:0.9rem 1.6rem;border-radius:999px;color:#021226;text-decoration:none;background:linear-gradient(90deg,var(--primary),var(--magenta));font-weight:600;">Explore the science</a>
  </section>

  <!-- CHAOS -->
  <section id="chaos">
    <div class="section-bg" style="background-image:url('https://upload.wikimedia.org/wikipedia/commons/6/68/BunimovichStadium.png');"></div>
    <h2 class="section-title">The Chaos Beneath</h2>
    <div class="content">Chaotic classical systems (sensitive dependence on initial conditions) manifest in billiards, pendula, and many physical systems. Below is an interactive Bunimovich stadium billiard — click the canvas to add particles and toggle dynamics parameters to see how trajectories respond.</div>

    <div class="visualization-container" id="billiard-box">
      <canvas id="billiard-canvas"></canvas>

      <!-- controls for the billiard sim -->
      <div class="controls" aria-hidden="false">
        <label title="Trail toggles fading trace">
          <input id="trail-toggle" type="checkbox" checked> Trail
        </label>
        <label title="Toggle specular (mirror) vs 'no-slip' style bounce">
          <select id="bounce-mode" aria-label="Bounce mode" style="background:transparent;color:var(--muted);border:0;outline:none">
            <option value="specular">Specular (mirror)</option>
            <option value="no-slip">No-slip (angular change)</option>
          </select>
        </label>
        <label title="Global friction">
          μ <input id="friction" type="range" min="0" max="0.01" step="0.0005" value="0.0008">
        </label>
      </div>
    </div>

    <div class="content" style="margin-top:1rem;">Tip: click to add particles, or press 'c' to clear. This sim implements the Bunimovich stadium: a rectangle capped with semicircles — a classic chaotic billiard geometry.</div>
  </section>

  <!-- TRAPPED IONS -->
  <section id="trapped-ions">
    <div class="section-bg" style="background-image:url('https://images.unsplash.com/photo-1531058020387-3be344556be6?ixlib=rb-4.0.3&auto=format&fit=crop&w=2070&q=80');"></div>
    <h2 class="section-title">Trapped Ions: Quantum Billiards</h2>
    <div class="content">Ion traps behave like microscopic billiard tables — boundary geometry, collision rules, and controlled perturbations let physicists probe complex quantum dynamics and, potentially, leverage scarring for hardware resilience.</div>

    <div class="visualization-container">
      <div style="display:flex;align-items:center;justify-content:center;height:100%;flex-direction:column;padding:1.6rem;">
        <i class="fas fa-atom" style="font-size:3rem;background:var(--gradient);-webkit-background-clip:text;background-clip:text;color:transparent;margin-bottom:0.6rem;"></i>
        <h3 style="margin-bottom:0.5rem;">Quantum "billiards" at small scales</h3>
        <p style="max-width:680px;text-align:center;">Your research tuning collision parameters maps directly onto trap boundary conditions and dissipation engineering — tools that experimentalists can use to produce robust quantum states.</p>
      </div>
    </div>
  </section>

  <!-- SCARRING -->
  <section id="scarring">
    <div class="section-bg" style="background-image:url('https://images.unsplash.com/photo-1502134249126-9f3755a50d78?ixlib=rb-4.0.3&auto=format&fit=crop&w=2070&q=80');"></div>
    <h2 class="section-title">The Quantum Scar Mystery</h2>
    <div class="content">Quantum scars are enhanced wavefunction density along unstable periodic orbits of the corresponding classical system — a bridge between classical chaos and quantum structure. They can be engineered and measured in various platforms.</div>

    <div class="visualization-container">
      <div style="padding:1.6rem;text-align:center;">
        <i class="fas fa-search" style="font-size:3rem;background:var(--gradient);-webkit-background-clip:text;background-clip:text;color:transparent;margin-bottom:0.6rem;"></i>
        <h3>Scars: ghosts of classical orbits</h3>
        <p style="max-width:700px;margin:0 auto;">Practical scarring control may improve gate fidelities and reduce heating in ion traps by stabilizing desired eigenstates against noise.</p>
      </div>
    </div>
  </section>

  <!-- APPLICATIONS -->
  <section id="applications">
    <div class="section-bg" style="background-image:url('https://images.unsplash.com/photo-1581091870626-3c4b4a9a6fef?ixlib=rb-4.0.3&auto=format&fit=crop&w=2070&q=80'); opacity:0.08;"></div>
    <h2 class="section-title">Quantum Computing Applications</h2>
    <div class="content">Controlled scarring opens paths to improved coherence, engineered gate operation, and specialized state preparation. As experimentalists tune trap geometry and collision parameters, theoretical predictions like yours become directly testable.</div>

    <div class="research-benefits">
      <div class="benefit-card"><div class="benefit-icon"><i class="fas fa-shield-alt"></i></div><h4>Reduced decoherence</h4><p style="font-size:0.95rem;">Scarred states can be less sensitive to some noise channels — increasing usable coherence time.</p></div>
      <div class="benefit-card"><div class="benefit-icon"><i class="fas fa-bolt"></i></div><h4>Lower heating</h4><p style="font-size:0.95rem;">Geometry-informed traps can reduce energy absorption and heating of motional modes.</p></div>
      <div class="benefit-card"><div class="benefit-icon"><i class="fas fa-cogs"></i></div><h4>Improved gates</h4><p style="font-size:0.95rem;">Stable scarred eigenstates can make certain gate operations more precise.</p></div>
    </div>
  </section>

  <!-- CTA -->
  <section id="cta">
    <div class="section-bg" style="background-image:url('https://images.unsplash.com/photo-1502134249126-9f3755a50d78?ixlib=rb-4.0.3&auto=format&fit=crop&w=2070&q=80'); opacity:0.06;"></div>
    <h2 class="section-title">Join the Quantum Frontier</h2>
    <div class="content">If you're a student or researcher: try the interactive billiard below, experiment with collision rules, and use the references to read the classic literature (Heller 1984 et al.) — then reach out to labs working on ion traps or quantum hardware.</div>
    <a class="cta-button" href="#" style="margin-top:1rem;padding:0.9rem 1.4rem;border-radius:999px;color:#021226;text-decoration:none;font-weight:700;background:linear-gradient(90deg,var(--primary),var(--magenta));">Start your quantum journey</a>
  </section>

  <!-- References -->
  <div class="refs" id="references" style="margin-bottom:2rem;">
    <h3 style="color:var(--muted); margin-bottom:0.4rem;">References & Image Attributions</h3>
    <ul>
      <li>Heller, E. J., "Bound-State Eigenfunctions of Classically Chaotic Hamiltonian Systems: Scars of Periodic Orbits", Phys. Rev. Lett. 53, 1515 (1984) — classic scar paper (look up for full text).</li>
      <li>Double pendulum long exposure (hero image): George Ioannidis / Wikimedia Commons. :contentReference[oaicite:3]{index=3}</li>
      <li>Bunimovich stadium / billiard diagram: Wikimedia Commons (motion & stadium diagrams). :contentReference[oaicite:4]{index=4}</li>
      <li>GitHub Pages hosting & quickstart (how to deploy): GitHub Docs. :contentReference[oaicite:5]{index=5}</li>
    </ul>
  </div>

  <footer>
    <div>Quantum Scarring Research &copy; <span id="year"></span> — interactive demo & resources.</div>
    <div style="margin-top:0.4rem; font-size:0.85rem; color:var(--muted);">
      Host on GitHub Pages by creating a repo named <code>yourusername.github.io</code> and pushing this file (or enable Pages from a branch in a project repo). GitHub Pages serves static HTML/CSS/JS (works with the canvas and scripts below). For details see GitHub Pages Quickstart. :contentReference[oaicite:6]{index=6}
    </div>
  </footer>

<script>
  document.getElementById('year').innerText = new Date().getFullYear();

  /* -------------------------
     NAV + SCROLL-SNAP LOGIC
     - relies on CSS scroll-snap for actual snapping.
     - IntersectionObserver updates active nav dot reliably.
     ------------------------- */
  (function initNav(){
    const dots = Array.from(document.querySelectorAll('.nav-dots .dot'));
    const sections = Array.from(document.querySelectorAll('section'));

    // click handlers
    dots.forEach(d => d.addEventListener('click', () => {
      const id = d.getAttribute('data-section');
      const el = document.getElementById(id);
      if (el) el.scrollIntoView({behavior:'smooth', block:'start'});
    }));

    // keyboard nav for accessibility
    window.addEventListener('keydown', (ev) => {
      if (ev.key === 'ArrowDown' || ev.key === 'ArrowUp') {
        ev.preventDefault();
        const center = window.innerHeight/2;
        let idx = sections.findIndex(s=>{
          const r = s.getBoundingClientRect();
          return r.top <= center && r.bottom >= center;
        });
        if (idx === -1) idx = 0;
        if (ev.key === 'ArrowDown') idx = Math.min(sections.length-1, idx+1);
        else idx = Math.max(0, idx-1);
        sections[idx].scrollIntoView({behavior:'smooth', block:'start'});
      }
    });

    // update active dot with IntersectionObserver
    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (!entry.isIntersecting) return;
        const id = entry.target.id;
        dots.forEach(d => d.classList.toggle('active', d.dataset.section === id));
      });
    }, { threshold: 0.55 });

    sections.forEach(s => io.observe(s));
  })();

  /* -------------------------
     Bunimovich Stadium Billiard Simulation
     - Canvas-based, lightweight
     - Click to add particles, press 'c' to clear
     - Supports specular vs "no-slip" style bounce (simple angular transfer)
     - Controls: trail, friction
     - This is a demo; physics simplified for clarity & performance.
     ------------------------- */
  (function billiardSim(){
    const canvas = document.getElementById('billiard-canvas');
    const ctx = canvas.getContext('2d', { alpha: true });
    let dpr = window.devicePixelRatio || 1;

    function resize(){
      dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawStatic(); // redraw walls
    }
    window.addEventListener('resize', resize);
    resize();

    // stadium geometry (in canvas coordinates)
    function makeStadium(w, h, r){
      // stadium centered horizontally; rect width = w, semicircles radius r on left+right
      // we keep it inside some padding
      const pad = 20;
      const left = pad + r;
      const right = (canvas.clientWidth - pad) - r;
      const top = pad;
      const bottom = canvas.clientHeight - pad;
      // ensure w matches left-right distance
      return { left, right, top, bottom, r, centerY: (top+bottom)/2 };
    }
    let stadium = makeStadium(canvas.clientWidth*0.6, null, Math.min(80, canvas.clientHeight*0.18));

    // particle state: x, y, vx, vy, color
    const particles = [];

    // controls
    const trailToggle = document.getElementById('trail-toggle');
    const bounceMode = document.getElementById('bounce-mode');
    const frictionControl = document.getElementById('friction');

    // draw static stadium walls on an offscreen canvas for speed
    const off = document.createElement('canvas');
    const offCtx = off.getContext('2d');

    function rebuildOffscreen(){
      off.width = canvas.width;
      off.height = canvas.height;
      offCtx.clearRect(0,0,off.width,off.height);
      const s = stadium = makeStadium(canvas.clientWidth*0.6, null, Math.min(120, canvas.clientHeight*0.18));
      const L = s.right - s.left;
      const r = s.r;
      const cy = s.centerY;

      offCtx.save();
      offCtx.translate(0,0);
      // fill background subtle
      offCtx.fillStyle = 'rgba(5,6,18,0.0)';
      offCtx.fillRect(0,0,off.width,off.height);

      // path: left semicircle -> rect -> right semicircle
      offCtx.beginPath();
      offCtx.arc(s.left, cy, r, Math.PI/2, Math.PI*1.5, true); // left semicircle (top->bottom)
      offCtx.lineTo(s.right, cy - r);
      offCtx.arc(s.right, cy, r, Math.PI*1.5, Math.PI/2, true); // right semicircle
      offCtx.closePath();

      // stroke & soft fill
      offCtx.fillStyle = 'rgba(255,255,255,0.02)';
      offCtx.fill();
      offCtx.lineWidth = 1.5;
      offCtx.strokeStyle = 'rgba(255,255,255,0.06)';
      offCtx.stroke();

      // subtle center axis
      offCtx.beginPath();
      offCtx.moveTo(s.left - r - 10, cy); offCtx.lineTo(s.right + r + 10, cy);
      offCtx.strokeStyle = 'rgba(255,255,255,0.02)';
      offCtx.lineWidth = 0.6;
      offCtx.stroke();

      offCtx.restore();
    }

    rebuildOffscreen();
    function drawStatic(){ ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight); ctx.drawImage(off, 0, 0, canvas.clientWidth, canvas.clientHeight); }

    // utility: random pastel color for particle
    function randColor(){
      const hues = [180, 200, 260, 300];
      const h = hues[Math.floor(Math.random()*hues.length)];
      return `hsl(${h} ${65 + Math.random()*20}% ${55 + Math.random()*10}%)`;
    }

    // check collision and reflect for stadium
    function reflectParticle(p){
      // map to stadium coordinates
      const s = stadium;
      const x = p.x, y = p.y;
      const r = s.r;
      const cy = s.centerY;

      // determine region: left semicircle, rectangle, right semicircle
      if (x < s.left) {
        // left semicircle centered at (s.left, cy)
        const dx = x - s.left, dy = y - cy;
        if (dx*dx + dy*dy > r*r) return false; // outside; we clamp later
        // normal vector:
        let nx = dx / Math.hypot(dx,dy), ny = dy / Math.hypot(dx,dy);
        // bounce depending on mode
        applyBounce(p, nx, ny);
        return true;
      } else if (x > s.right) {
        const dx = x - s.right, dy = y - cy;
        if (dx*dx + dy*dy > r*r) return false;
        let nx = dx / Math.hypot(dx,dy), ny = dy / Math.hypot(dx,dy);
        applyBounce(p, nx, ny);
        return true;
      } else {
        // rectangle top/bottom
        if (y < s.top) { applyBounce(p, 0, -1); return true; }
        if (y > s.bottom) { applyBounce(p, 0, 1); return true; }
      }
      return false;
    }

    // simple bounce: reflect velocity about normal. Also supports "no-slip" simple rule:
    function applyBounce(p, nx, ny){
      const mode = bounceMode.value;
      // velocity vector
      let vdotn = p.vx*nx + p.vy*ny;
      // specular (mirror)
      if (mode === 'specular') {
        p.vx = p.vx - 2*vdotn*nx;
        p.vy = p.vy - 2*vdotn*ny;
      } else {
        // no-slip-ish: reflect normal component, reduce tangential component slightly (simulate angular transfer)
        // tangential vector (perpendicular to normal)
        let tx = -ny, ty = nx;
        let vt = p.vx*tx + p.vy*ty;
        // reflect normal
        let vn = -vdotn;
        // damp tangential a bit to mimic energy transfer (toy model)
        vt *= 0.95;
        p.vx = vn*nx + vt*tx;
        p.vy = vn*ny + vt*ty;
      }
      // small energy loss on bounce
      p.vx *= 0.9995; p.vy *= 0.9995;
    }

    // clamp particle inside domain (push inside)
    function clampToDomain(p){
      const s = stadium;
      const r = s.r, cy = s.centerY;
      if (p.x < s.left - r) p.x = s.left - r + 1;
      if (p.x > s.right + r) p.x = s.right + r - 1;
      if (p.y < s.top - 10) p.y = s.top + 5;
      if (p.y > s.bottom + 10) p.y = s.bottom - 5;
      // if inside left/right semicircle and outside circle, push inwards
      if (p.x < s.left) {
        const dx = p.x - s.left, dy = p.y - cy;
        const dist = Math.hypot(dx,dy);
        if (dist > r - 0.5) {
          p.x = s.left + dx * (r - 1)/dist;
          p.y = cy + dy * (r - 1)/dist;
        }
      }
      if (p.x > s.right) {
        const dx = p.x - s.right, dy = p.y - cy;
        const dist = Math.hypot(dx,dy);
        if (dist > r - 0.5) {
          p.x = s.right + dx * (r - 1)/dist;
          p.y = cy + dy * (r - 1)/dist;
        }
      }
    }

    // animation loop
    let last = performance.now();
    function frame(ts){
      const dt = Math.min(0.04, (ts - last)/1000);
      last = ts;
      // fade/trail
      if (!trailToggle.checked){
        ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
        ctx.drawImage(off, 0, 0, canvas.clientWidth, canvas.clientHeight);
      } else {
        // subtle fade for trails
        ctx.fillStyle = 'rgba(5,6,18,0.06)';
        ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);
        ctx.drawImage(off, 0, 0, canvas.clientWidth, canvas.clientHeight);
      }

      const mu = parseFloat(frictionControl.value);

      // update particles
      for (let p of particles){
        p.x += p.vx * dt * 60;
        p.y += p.vy * dt * 60;

        // friction
        p.vx *= (1 - mu*dt*60);
        p.vy *= (1 - mu*dt*60);

        // reflect on collisions — if reflectParticle returns true it's because we collided
        // but we also defensively clamp
        reflectParticle(p);
        clampToDomain(p);

        // draw trail dot
        ctx.beginPath();
        ctx.fillStyle = p.color;
        ctx.globalAlpha = 1.0;
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
        ctx.fill();
      }

      requestAnimationFrame(frame);
    }

    // initial drawing
    drawStatic();
    requestAnimationFrame(frame);

    // add particle on click
    canvas.addEventListener('click', (ev) => {
      const r = canvas.getBoundingClientRect();
      const x = (ev.clientX - r.left);
      const y = (ev.clientY - r.top);
      // random small velocity
      const ang = Math.random()*Math.PI*2;
      const speed = 1.8 + Math.random()*2.6;
      particles.push({ x, y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, color: randColor(), radius: 3 + Math.random()*2 });
    });

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'c') { particles.length = 0; drawStatic(); }
      if (e.key === 'a') {
        // add a few random particles
        for(let i=0;i<6;i++){
          const x = stadium.left + (stadium.right - stadium.left) * Math.random();
          const y = stadium.top + (stadium.bottom - stadium.top) * Math.random();
          const ang = Math.random()*Math.PI*2; const speed = 1.5 + Math.random()*2.5;
          particles.push({ x, y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, color: randColor(), radius: 3 + Math.random()*2 });
        }
      }
    });

    // when resizing viewport, rebuild stadium layout & offscreen
    let resizeObserver = new ResizeObserver(() => {
      rebuildOffscreen();
      drawStatic();
    });
    resizeObserver.observe(canvas);

  })();

  /* -------------------------
     Small UX helpers (fade-in animations on visibility)
     ------------------------- */
  (function initFadeIns(){
    const els = document.querySelectorAll('.content, .section-title, .hero-title');
    const io = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.style.opacity = 1;
      });
    }, { threshold: 0.1 });
    els.forEach(e=> { e.style.opacity = 0; io.observe(e); });
  })();

</script>
</body>
</html>
